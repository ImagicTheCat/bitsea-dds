= BitSea Distributed Data System
:toc: left

BitSea is a distributed data system which aims to implement immutable, mutable and discoverable distributed content. Major inspirations are https://en.wikipedia.org/wiki/BitTorrent[BitTorrent], https://en.wikipedia.org/wiki/ZeroNet[ZeroNet] and https://en.wikipedia.org/wiki/InterPlanetary_File_System[IPFS].

It can result in a robust, offline, long-term, independent access to structured data and can be a component of the distributed web.

== Principles

The system is fundamentally about data and its semantic; the way data is exchanged is independent of the specification. However, because actual applications should exist, the system is designed with concerns about how it will be implemented.

The concept is as follows: each _user_ has a _shore_ where its data of interest is stranded; then by the use of a _seaport_ that data can be exchanged with other shores across the sea through _seaways_.

With more technical words, a user can be seen as a *node*, the shore is its *storage*, the seaport is the *client application* and the seaways are *exchange protocols*.

TIP: The way data is exchanged may be implemented in multiple ways, e.g. being part of a P2P mesh network or requesting an HTTP gateway (through https://en.wikipedia.org/wiki/Tor_(network)[Tor] if anonymity is necessary) which would be connected to a mesh network; the data could even be manually imported from physical storage.

.What the system is about
- Sharing. Distributed applications.
- Focused on data, independent of a specific exchange protocol; being offline.
- Data verifiability, resilience, persistence, durability.
- A balance between simplicity and flexibility.

.What the system is not about
- Confidentiality. The system is not about storing private data footnote:[But exchange protocols may guarantee that a specific resource, a block, pointer or topic, can only be discovered by knowing its identifier first.].
- Fast, reactive, very dynamic data, e.g. chatting or live streaming.
- Temporary or transport-based data, e.g. emails.
- Replacing the Web. BitSea may be a component of the distributed web, but it doesn't aim to be _the_ distributed web.

NOTE: The system specification *must* be backwards compatible.

== Data objects

.There are two types of data objects:
Block:: A content-addressed piece of data, i.e. by a cryptographic hash, which has a reasonable size like 256kiB.
Pointers:: A mutable reference to a block, signed with a timestamp by an identity. The pointer can be unbound or bound to a specific block.

.This results in two more concepts:
Identity:: A public key owned by an entity.
Topic:: A block identifier which may have bound pointers.

Blocks define immutable content, pointers are a layer above to implement mutable content and topics are a way to discover content via bound pointers.

A block may contain anything, e.g. references to other blocks to build a Hash DAGfootnote:[Also called a Merkle DAG in reference to Merkle Trees, but may be ambiguous.] (https://en.wikipedia.org/wiki/Directed_acyclic_graph[Directed Acyclic Graph]).

NOTE: In the context of BitSea, a Hash DAG is a directed graph where a node is a data block referenced by the cryptographic hash of its content, which holds the references to its children. By the properties of the cryptographic hashing function, the graph can only be built from the children to the parents and cycles are not possible.

TIP: Complex data structures can be built on blocks and the system defines some. It is possible to create new kind of structures; _seaports_ or other applications may interpret them.

=== Block

The accepted size of a block is enforced by the _seaport_ and _seaways_ implementations, but a size between 0 and 512kiB while aiming towards 256kiB is recommended. This is based on current P2P sharing system policies and the required flexibility for techniques like Content-Defined Chunking.

.EBNF-like specification
----
block-identifier-v1 = 0x00 hash
hash = <BLAKE2b-256 hash of the content, 32 bytes>

block-content = type-header content-data
type-header = size {byte}
size = <8 bit unsigned integer, 0-255, 1 byte>
content-data = {byte}
----

A block identifier (version 1) is a sequence of 33 bytes. The content `hash` is computed using https://en.wikipedia.org/wiki/BLAKE_(hash_function)[BLAKE2b-256], i.e. the BLAKE2b algorithm with an output of 32 bytes (256 bits) and default parameters.

A block content start with a `type-header`, a byte sequence between 0 and 255 bytes which defines its data type. An empty `type-header` of `size` 0 describes a raw data block. The `type-header` can be used by anyone to build new data structures or formats from blocks.

=== Pointers

.EBNF-like specification
----
identity-identifier-v1 = 0x80 public-key
public-key = <Ed25519 public key, 32 bytes>

pointer-content-v1 = timestamp block-identifier-v1 signature
timestamp = <64 bit unsigned integer, 8 bytes, little-endian>
signature = <Ed25519 signature of previous content, 64 bytes>

bound-pointer-content-v1 = timestamp block-identifier-v1 bound-block-identifier-v1 signature
bound-block-identifier-v1 = block-identifier-v1
----

An identity identifier (version 1) is a sequence of 33 bytes. The `public-key` is the sequence of an https://en.wikipedia.org/wiki/EdDSA[Ed25519] public key bytes.

NOTE: The version of the pointer content is inferred from the version of the identity identifier.

The `timestamp` should be set at the https://en.wikipedia.org/wiki/Unix_time[Unix time] date of modification. Newer versions of a pointer should replace the current one if their `timestamp` is strictly greater and not from the future. Because time can vary from a system to another, a _seaport_ may use an error margin for the comparison.

An unbound pointer is accessed by its identity identifier. A bound pointer is accessed by its identity identifier and its bound block identifier. A topic is accessed by a block identifier and results in the discovery of the associated bound pointers.

TIP: A _seaport_ may keep an history of all the updates to a pointer to allow users to access the previously pointed blocks.

== Data structures

A data structure is built on blocks; generally, this will result in a Hash DAG of blocks.

=== File / Blob

=== Key-value store

=== Directory

== Uniform Resource Identifier

A resource of the system is equivalent to a specific block, which can describe a data structure or may be interpreted as a topic.

A BitSea URI follows the https://datatracker.ietf.org/doc/html/rfc3986[generic URI specification] and uses the `bitsea` scheme.

Each step of the URI path resolves to a resource, i.e. a block.

.EBNF-like partial specification
----
scheme = "bitsea"
root-segment = block | pointer | bound-pointer | alias
block = <base128btc encoding of the block identifier>
identity = <base128btc encoding of the identity identifier>
pointer = identity
bound-pointer = identity "." block
----

The `base128btc` alphabet is specifically `123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz`.

NOTE: The incentives for `base128btc` encoding is human-readability and composition: short strings, less ambiguity, no special characters.

A `pointer` or `bound-pointer` resolves to the pointed resource.

The `alias` is an URI root segment which doesn't match the previously defined root segments. It resolves to a locally named resource.

NOTE: A _seaport_ can provide pre-defined aliases and should allow the user to define more.

.Examples
block:: `bitsea:1CMn1nKMPqjFA2PxcA2vihGyhTZ9vPjDhGu7hHZVj464H/...`
pointer:: `bitsea:fJx4T3yQnDbUsNRkTzoH9YJz9hAqSsA9JyFu3PA5f7o4P/...`
bound pointer:: `bitsea:fJx4T3yQnDbUsNRkTzoH9YJz9hAqSsA9JyFu3PA5f7o4P.1CMn1nKMPqjFA2PxcA2vihGyhTZ9vPjDhGu7hHZVj464H/...`
alias and directory fetch:: `bitsea:org/wikipedia/...`

=== Data structures

==== Directory

A path segment from a directory resolves to the resource (block or pointers) assigned to that specific entry. The segment bytes are used as the key.

==== Key-value store

The URI fragment can be used to reference an entry of the key-value store.

== Limitations

This section explores the limitations of the system in the long-term.

=== If a weakness is found on the hashing algorithm

=== If a Weakness is found on the asymmetric signature algorithm

== Example applications

=== Name provider

=== Identity provider

=== Forum
